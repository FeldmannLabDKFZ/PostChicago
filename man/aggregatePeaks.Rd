% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PostChicagoTidyNestedRemoved.R
\name{aggregatePeaks}
\alias{aggregatePeaks}
\title{Aggregate Interactions to Interaction Peaks}
\usage{
aggregatePeaks(ints, dis, samples, fileprefix = "ints")
}
\arguments{
\item{ints}{table containing all interactions that should be aggregated}

\item{dis}{numeric, distance in restriction fragments over which interactions should be aggregated.
dis=1 will merge two adjacent fragments with significant interactions.}

\item{samples}{Character vector of sample names, should correspond to the sample names used in ints.
Typically corresponding to the names provided in the list of chicagoData objects cd}

\item{fileprefix}{start of the filename for the aggregatePeaks table file, will be added the following extension:
paste0('_aggregatePeaks_in_regions_',dis,'bp.txt'). Should contain path if required to be saved in a different folder. Default: ints.}
}
\value{
A table containing the position of aggregated interactions. Redefines intIDs so that the ID of the
first interacting fragment in a peak stands in as otherEnd.
Data is automatically saved in a 'aggregatePeaks_dis' text file whose name is defined by fileprefix and dis.
Also saved as a bedfile.
}
\description{
Takes a table of interactions (ints) and aggregates interactions with the same bait over the distance dis in
restriction fragments. Only creates the table if it is not yet saved. Otherwise loads the existing table.
Caution: All interactions, regardless the sample from which they originated, are aggregated,
similarly to the reduce() function from GenomicRanges.
}
\examples{
# example code:
extdata <- system.file("extdata", package="PostChicago")
outputDir <- file.path(extdata,'postchicago')

#read in the interactions table:
ints=read.delim(paste0(outputDir,'/ints_all.txt'),stringsAsFactors=FALSE)

#aggregate all peaks within a distance of 5 restriction fragments
dis=5
samples=names(ints)[grep('_N$',names(ints))]
samples=strsplit_string(samples,s2='_N')
aggregatePeaks(ints,dis,samples)

}
